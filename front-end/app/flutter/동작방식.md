# 동작방식

`Swift`로 `iOS`를, `Java`로 `Android` Native application을 구축할 때에는, 운영체제에게 해당 요소들을 만들어달라고 요청하는 과정을 거치게 된다.

반면 `Flutter`은 운영체제에게 직접적으로 요청하지 않고, 간접적으로 이러한 과정을 진행한다.  
즉, `Flutter`은 실제 네이티브 버튼 등을 만들어내지 않는다. 대신 비디오 게임 엔진같이 동작하게 된다.

`Dart`로 짜여진 코드는 `Flutter` 프레임워크에서 추상화한 여러 요소로 변환이 된다.  
이때, 이 요소들은 운영체제로부터 만들어달라는 요청을 하지 않고 엔진을 사용한다.

이 엔진은 `C`, `C++`로 만들어졌고, UI를 렌더링하는 엔진으로 사용된다.  
그리고 이 엔진은 화면 상에 우리가 말한 것들을 그려낸다.

`Unity`는 코드를 패키징한 후 앱스토어로 보내고, 이 앱을 다운도르 받으면 그 앱이 내 코드를 실행시키는 원리이다.

플러터도 마찬가지다. `Flutter` 앱과 코드가 있다면, 이를 엔진이 실행시키는 원리이다.

즉, `Flutter`은 운영체제에 내장된 플랫폼의 `Native Widget`을 사용하지 않는다.  
엔진은 모든 것들을 그려주고, 운영체제는 어떠한 것들도 그려주지 않고, 동작만 시켜줄 뿐이다.

엔진이 프레임워크를 동작 및 그려줄 뿐이고 운영체제가 엔진을 돌려줄 뿐이다.  
그리고 `Dart` 코드는 네이티브 ARM 라이브러리로 컴파일된다.

**호스트 플랫폼이 엔진을 동작시키면, 엔진은 Dart Flutter 코드를 동작시키는 것이다.**

우리가 애플리케이션을 다운로드 받은 후 실행시키면, 엔진은 `runner` iOS 프로젝트를 열게되고, 이는 엔진이 코드를 실행하도록 한다.

안드로이드 역시 C와 C++로 짜여진 엔진은 안드로이드의 NDK와 함께 컴파일된다.  
플랫폼이 다르기 때문이다.

코드는 네이티브와 ARM, x86 라이브러리로 컾마일된다.  
이 라이브러리들은 안드로이드 프로젝트에 포함되며, 모든 것은 `.apk`로 빌드된다.

# 문제점

플러터는 결국 엔진이 `Dart` 코드를 실행시키는 과정에서, 네이티브 위젯을 사용하지 않는다.  
즉, 실제 모든 UI 요소의 기능들을 완전히 동일하게 구성하지는 못했다.

이는 운영체제를 통해 요청하지 않기 때문이다.

네이티브 위젯을 사용할 수 없기에 좀 더 부자연스럽다는 것은 비판점으로 평가되고 있다.

# 장점

운영체제의 호스트와 직접적으로 이야기하지 않는 방식.  
단순히 엔진을 애플리케이션 내부에 집어넣고, 우리의 코드를 컴파일한다.  
이후 운영체제에서 애플리케이션을 실행할 때 `runner` 프로젝트를 실행시킨다.

`Embedder`은 엔진을 가동시키는 runner 프로젝트를 가리킨다.  
운영체제마다 다양한 `Embedder`가 존재하며, 이는 호스트 플랫폼 상에서 엔진을 가동시키는 역할을 한다.
즉, `Flutter`은 애플리케이션의 캔버스 역할을 한다.

애플리케이션이 시작되면 엔진은 위젯들을 그려준다.  
이는 단순히 캔버스를 그려내지 다른 호스트와 직접적으로 소통하지 않는다.

엔진을 또다른 하나의 자바의 가상 머신이라고 생각해도 된다.  
자바의 가상 머신이 코드를 실행하는 것처럼 말이다.

반면 이러한 렌더링 엔진을 별도로 구축한다는 것이 장점이기도 하다.  
렌더링 엔진에 의해 바뀌는 UI 요소는 플러터 자체가 통제하기 때문에, 더이상 애플리케이션 호스트를 의존할 필요가 없어진다.
