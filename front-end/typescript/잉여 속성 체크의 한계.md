# 잉여 속성 체크의 한계

> <이펙티브 타입스크립트>를 보며 꽤나 흥미로웠던 파트 중의 하나! 👀

타입스크립트는 타입이 명시된 변수에 객체 리터럴을 할당할 때

+ 해당 타입의 속성이 었는지
+ 그 외 속성이 없는지를 확인한다.

```ts
interface Room {
  numDoors: number;
}

const r: Room  = {
  numDoors: 1,
  etc: 2
} // 객체 리터럴은 알려진 속성마 지정 가능하며, 'Room' 형식에는 `etc`가 없습니다.
```

위는 되지 않는 구문이다.  

그러나 신기하게도 아래의 코드는 오류를 뱉지 않고 타입 체커를 통과한다.

```ts
const wtf = {
  numDoors: 1,
  etc: 2
};

const r: Room = wtf;
```


왜 그럴까?

### 할당 가능 검사 vs 잉여 속성 체크

먼저 전자는 구조적 타입 시스템에서 발생 가능한 오류를 잡기 위해 **잉여 속성 체크** 과정을 수행했다.

그런데 이러한 잉여 속성 체크는 조건에 따라 동작하지 않고, 통상적인 할당 가능 검사화 함께 쓰이면 구조적 타이핑이 무엇인지 혼란스러워질 수 있다.

따라서 반드시 두 검사가 **별도의 과정**임을 인지해야 한다.

타입스크립트는 의도와 다르게 작성된 코드까지 찾아내려 한다. 따라서 잉여 속성까지 체크한다.  
(예컨대 오타로 작성된 코드들까지 내뱉는 경우를 포함한다.)

그런데 이러한 깐깐한 검사는 객체 리터럴에서 발동한다.

따라서 만약 변수로 할당을 해주었다면, 할당 가능 검사만 진행하게 되고, 오류 검사를 통과하게 된다는 것이다.

### 그 외 
특히 이러한 잉여 속성 체크는 
+ 타입 단언문을 사용할 때
+ 인덱스 시그니처를 활용할 때에도 적용되지 않는다.

다만, 선택적 속성만 가지는 약한 타입에서는 적용이 된다고 한다!  
왜냐하면, 공통된 속성이 있어야 하기 때문에 별도의 체크를 수행한다.

이러한 잉여 속성 체크로 인해 우리는 속성 이름의 오타를 바로잡을 수 있게 된 것이다.

### 요약

1. 객체 리터럴을 변수에 할당하거나 함수에 매개변수로 전달할 때 잉여 속성 체크가 수행된다.
2. 타입스크립트 타입 체커가 수행하는 일반적인 구조적 할당 가능성 체크와 잉여 속성 체크는 다르다. 따라서 할당의 개념을 알고 정확히 둘을 구분할 줄 알아야 한다.
3. 잉여 속성 체크는 임시 변수를 도입하면 건너뛸 수 있다는 것을 주의해야 한다.



