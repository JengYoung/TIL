## 타입스크립트 컴파일러 역할

+ 최신 타입스크립트 / 자바스브립트를 브라우저에서 동작할 수 있도록 구버전의 자바스크립트로 트랜스파일한다.
+ 코드의 타입 오류를 체크한다.

> 여기서 이 두 개의 역할은 완전히 독립적이다.

따라서 타입 체크는 트랜스파일링 시 영향을 받지 않으며, 동시에 타입 체크가 트랜스파일링에 영향을 주지도 않는다.

이로 인해 다음과 같은 문제들이 파생된다.

### 1. 타입 오류가 있는 코드 역시 빌드가 가능하다.

타입 체크는 트랜스파일링에 영향을 주지 않기 때문이다.

따라서 타입 오류는 빌드에 영향을 미치지 않으며 다만 경고문을 남긴다.

> 만약 오류가 있을 때에는 컴파일을 하지 않도록 하려면 `noEmitOnError`을 써주자. 빌드가 되지 않도록 할 수 있다.

### 2. 런타임 시에는 타입 체크가 불가능하다.

타입스크립트의 타입은 컴파일되는 과정에서 모든 인터페이스, 타입, 타입 구문을 제거하고 자바스크립트 코드로 변환한다.

따라서 런타임 시에는 타입 체크의 역할을 수행할 수 없다.

### 3. 타입 연산은 런타임에 영향을 주지 않는다.

대표적으로 타입 단언이 있다. 

타입이 어떤 것인지 상정하는 것은 순전히 컴파일 당시에만 오류를 체크하지, 런타임에는 독립적으로 작용한다.

다만 타입 단언을 지나치게 사용하는 것은 오히려 타입스크립트의 장점을 저해하므로 사용을 줄이는 것을 권장한다.

### 4. 타입 선언의 타입이 런타입 시의 타입을 보장해주지 않는다.

이는 흔히 API 비동기 호출에서 발생한다. 

타입스크립트는 순전히 컴파일 당시의 값을 체크하기 때문에, 런타임 때의 타입과는 다르게 동작할 수 있다.

따라서 컴파일 당시에 값을 알 수 없는 것은, 따로 변수를 상정 후 예상되는 값을 타입으로 선언해주면 더욱 가독성 높은 코드를 작성할 수 있다.

### 5. 타입스크립트는 함수 오버로드를 지원하지 않는다.

이건 매우 당연하다. 결과적으로 여러 개를 만들더라도 타입 수준에서만 동작한다.
여러 개의 선언문을 하나의 함수에 대해 작성할 수 있지만, 구현체는 오직 하나뿐이다.