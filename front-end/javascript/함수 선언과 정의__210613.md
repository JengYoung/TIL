# **함수**

> 입력을 받아 출력을 내보내는 일련의 과정을 문으로 구현하고 코드 블럭으로 감싸진 실행 단위

```
// 함수 정의
function 함수이름(매개변수) {
    return 반환값
}

// 함수 호출
함수이름(인수)
```

으로 구성되어 있다.

## **함수의 목적**

- 코드의 재사용성
- 유지보수의 편의성
- 코드의 신뢰성: 유지보수의 실수를 줄임.
- 코드의 가독성

## **함수 리터럴**

리터럴이란, 선언함과 동시에 값 또는 코드를 지정해주는 것을 말한다. 함수 리터럴 역시 **함수가 객체이기 때문에 객체 값**을 생성한다.

```
const functionliteral = function returnValue(x) {
    return x
}
```

> 구성요소

|   구성요소    | 설명                                                                                                                                                              |
| :-----------: | :---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|   함수 이름   | 1. 함수 이름은 식별자이므로 네이밍 규칙을 준수해야 함</br>2. 함수 이름은 함수 몸체 내에서만 참조</br>3. 함수 이름은 생략이 가능. 기명함수 - 무명(익명)함수로 나뉨 |
| 매개변수 목록 | 1. 0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분</br>2. 함수를 호출할 때 지정한 인수가 **순서대로 할당**</br>3. 함수 몸체 내에서 변수와 동일한 취급.          |
|   함수 몸체   | 1. 실행문들을 하나의 실행단위로 정의한 코드 블록</br> 2. 함수 호출에 의해 실행                                                                                    |

---

## **함수의 정의**

변수는 선언한다고 하지만, 함수는 **정의**한다고 표현한다.  
그 이유는 함수는 **선언문을 평가한 후에, 식별자가 암묵적으로 생성되고 객체가 할당되기 때문이다.**

함수 정의는 크게 4가지가 있다.

> - **함수 선언문** (`function x() {}`)
> - **함수 표현식** (`const y = function () 8 8{}`)
> - **Function 생성자 함수** (`const z = new Function('a', 'b', 'return a + b')`)
> - **화살표 함수** (`const w = () => {}`)

---

### **함수 선언문**

**표현식이 아닌 문**으로, 함수 이름을 생략할 수 없다. 따라서 실행 시 `console`창에 `undefined`가 출력된다.

그렇다면, 우리는 한 가지 의문이 생긴다.

```
const functionliteral = function returnValue(x) {
    return x
}
```

위의 코드는 왜 가능한 것인가?
**문이라면, 우항에 할당할 수 없다. 표현식이 아니기 때문이다.**

이는 자바스크립트 엔진이 해석하는 방식에서 기인한다.
기명 함수 리터럴은 함수 선언문 또는 함수 리터럴 표현식으로 **중의적으로 해석될 가능성이 있기 때문이다.**

```
function bar() {console.log('bar')}; // 함수 선언문. bar
(function bar() {console.log('bar')}); // 함수 리터럴 표현식으로 해석. -> bar is not defined
```

여기서 **함수 선언문과 함수 리터럴 표현식의 차이**가 드러난다.

함수 선언문은 호출할 수 있지만 함수 리터럴 표현식으로 생성된 함수는 함수 이름으로 호출할 수 없다.

그 과정을 서술하면 다음과 같다.

1. 함수를 호출한다.
2. 함수 이름은 함수 몸체에서만 참조할 수 있는 식별자다. 따라서 함수를 가리키는 식별자가 존재하지 않는다.
3. 이때 만약 함수 선언문이라면, 암묵적으로 식별자를 생성한다. 반면 표현식의 경우, 식별자를 생성하지 않으므로 함수 객체를 참조할 수 없다.

> 나만의 해석:  
> 함수 선언문은 **선언**을 한다. 따라서 어떤 함수가 있음을 알리면서 동시에 함수를 정의하기에, 식별자를 생성해낸다. (함수 이름은 몸체 내부에서만 유효하며, 밖에서는 참조하지 못하므로 호출할 수 없다)
> 하지만 표현식은 **값**에 집중한다. 따라서 값으로 할당될 때 생성자는 의미가 없기 때문에 (좌항에 이미 식별자를 생성한다는 측면에서) 참조를 못하는 듯하다.

### **함수 표현식**

먼저 다음을 상기하자.

> 함수는 값의 성질을 갖는 객체인 <u>**일급객체**</u>이다.

따라서 함수 리터럴이 가능한 것이며, 이를 통한 함수 정의 방식을 함수 표현식이라 하는 것이다.

---

## **함수 호출과 반환**

함수 호출은 표현식이다. 따라서 함수 호출은 `return`이 반환하는 반환값으로 평가된다.

이때 반환문은

> 1. 함수의 실행 중단 및 결과 반환
> 2. 반환문 이후 statement 무시

의 역할을 수행한다.

만약 반환문이 없을 시 함수는 암묵적으로 `undefined`를 반환한다.

```
const func = function(){}
console.log(func()) // undefined
```

또한 세미콜론 자동 삽입 기능에 주의해야 한다. 다음과 같은 경우, `return` 뒤에 자동으로 세미클론이 들어가므로 의도치 않은 결과가 발생한다.

```
function errorExample() {
    return
    2;
}
console.log(errorExample()); // undefined
```

## **참조에 의한 전달과 외부 상태 변경**

객체의 경우 `pass by reference`하므로 결과적으로 함수 내부에서 외부의 변수 상태에 접근할 수 있다.

```
function changeVal(primitive, obj) {
    primitive += 100;
    obj.name = 'Kim';
}

// 외부 상태
var num = 100;
var person = { name: 'Lee' };

console.log(num);
console.log(person);

// 원시 값: 값 복사 -> 할당. 따라서 원본 훼손 X
// 객체: 참조 값 전달 -> 원본과 같은 주소 공유 -> 원본 훼손
console.log(num); // 100
console.log(person); // { name: 'Kim' }
```

이는 결과적으로 코드의 내부 동작을 이해하는 데 복잡성을 높이며, 가독성을 해치는 원인이 된다.

### **해결 방법**

> 1. 객체를 불변 객체로 만들어 사용한다.
> 2. 만약 상태 변경이 필요하다면, 깊은 복사를 통해 새로운 객체를 생성하고 재할당을 통해 교체한다.
> 3. 순수 함수를 최대한 지향한다.
