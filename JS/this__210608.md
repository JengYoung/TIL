## **this란!**

`javascript`를 공부하면서 가장 의아했던 것 중 하나가 바로 `this`의 동작방식이었다.

먼저 `this`를 알기 전에 객체 지향 프로그래밍을 되짚어 보자.
모든 객체는

> 1. 상태 (property)
> 2. 동작 (method)

을 갖고 있다.

여기서 동작을 나타내는 메서드는 자신이 속한 객체를 가리키는 식별자를 참조할 수 있어야 할 것이다.
그렇지 않으면, 어떤 객체를 동작할 것인지를 명시하지 못하기 때문이다.

**이때 사용하는 것이 바로 자기 참조 변수(self-referencing variable)이다!**
주 역할은 다음과 같다.

> **자신이 속한 객체**, 또는  
> **자신이 생성할 인스턴스의 프로퍼티나 메서드**를 참조할 수 있다.

this는 암묵적으로 생성된다. 그리고, 코드 어디서든 참조할 수 있다.  
일반적으로 함수를 호출할 시 arguments와 this가 암묵적으로 전달된다고 한다.

그러나 다음 한 가지는 기억해야 한다.  
this가 가리키는 값(this 바인딩)은 **함수 호출 방식에 따라 동적으로 결정된다!**

> **this 바인딩**?
>
> - 식별자와 값을 연결하는 과정.
> - 즉, **this와 this가 가리킬 객체를 바인딩**하는 것.

이러한 동적 바인딩에는 크게 3가지 케이스가 있다.

- 일반 함수 호출 ✅(window)
- 메서드 호출
- 생성자 함수 호출 ✅(위의 new Person예시)

```
// 일반 함수 호출
// window 전역 객체에 this가 바인딩된다.
const young1 = Say('jengyoung')
console.log(window.greeting());

// 메서드 Case
// young2 객체에 this가 바인딩된다.
const young2 = {
    Say
};
young2.Say('Jengyoung');
young2.greeting();


// 생성자 함수 Case
// 새롭게 생성된 young3 객체에 this가 바인딩된다.
const young3 = new Say('Jengyoung');
young3.greeting();
```

이정도만 기억해도 된다면, 얼마나 편할까.  
문제는 콜백 함수가 실행될 때이다.

> 우리의 콜백 함수 역시 일반 함수로 호출되면 전역 객체로 바인딩 된다. 그렇다면 다음과 같은 상황이 발생한다!

```
function Clock () {
    this.time = Date.now()
    setTimeout (function() {
    	// window.time = Date.now() //이를 추가하면 현재 시간 출력
        console.log(this.time)
    }, 1000)
};

const nowTime = new Clock();
```

하... 역시 마찬가지로 `undefined`가 뜬다!
콜백 함수도 일반 함수로 호출되면, window 객체의 메소드로 생성되는 것이다!

이럴 때 해결 방법은 다음과 같다.

```
function Clock () {
    this.time = Date.now()
    const that = this;
    setTimeout (function() {
        console.log(that.time)
    }, 1000)
};

const nowTime = new Clock();
```

우리는 변수가 곧 어떤 값이 있는 메모리의 주소를 가리키고 있음을 알고 있다. 따라서 변수를 통해 this를 간접 참조하면 되는 것이다!

---

> ### 보다 명료하게 바인딩하고 싶어요!

이를 지원하기 위해 자바스크립트에서는 3가지 메서드를 제공하는데 그것이 바로

- `Function.prototype.apply`
- `Function.prototype.call`
- `Function.prototype.bind`

이다. 이제 이를 살펴보자!

### Function.prototype.apply & Function.prototype.call

> **`Function.prototype.apply(thisArg[, argsArray])`**  
> **`Function.prototype.call(thisArg[, arg1[, arg2[, ...]]])`**

> **`@param thisArg`**`this`로 사용할 객체
>
> **`@param argsArray`** 함수에게 전달할 인수 리스트의 배열 / 유사 배열 객체
>
> **`@returns`** 호출된 함수 반환 값

어떤 것을 부연설명할까 고민하다, 다음 예시를 만들었다.

```
function makeArr(...args) {
    console.log(args) // = arguments
    return this.arr;
}
const arrObj = { arr: [1,2,3], makeArr } // this -> arrObj
console.log(arrObj.makeArr(1,2,3)); //argsArray에 대응

const objective = [6,7,8,9,10]
console.log(arrObj.makeArr.apply({ arr: objective }, [6,7,8,9,10])) // this -> { arr: objective }, argsArray -> [6,7,8,9,10]
console.log(arrObj.makeArr.call({ arr: objective }, 6,7,8,9,10))
```
