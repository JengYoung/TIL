## **변수 선언 유형**

[변수](/210607.변수.md) 문서를 통해서 우리는 변수의 선언 과정까지 살펴봤다.
다음은 변수 선언에 대한 세부적인 설명을 살펴보자.

---

## **초기화 단계**

자바스크립트에서는 변수를 선언했지만 값이 할당되지 않았을 때, 이를 암묵적으로 `undefined`라는 값을 할당하고 초기화한다.

결국 변수 선언은 다음 2단계로 걸쳐 수행되는 것이다.

1. 선언 단계: 변수의 존재를 알리고
2. 초기화 단계: 메모리 공간 확보 및 암묵적인 `undefined` 할당

여기서 모든 식별자는 실행 컨텍스트에 등록된다.

> 실행 컨텍스트란 자바스크립트 엔진이 **소스를 평가, 실행하기 위해 필요한 환경을 제공하고 결과를 실제로 관리하는 영역**이다.
> 여기서 관리하는 것은 크게 **식별자와 스코프**이다.

식별자는 `key / value` 형식의 객체로 등록되어 관리된다.

---

## var

먼저 나온 변수를 선언할 수 있는 유형.

var은 암묵적으로 undefined를 할당하여 초기화를 자동 수행한다.
따라서 var은 쓰레기 값을 미리 처리한다는 점에서는 안전하다. 그러나

> 1.  블록 레벨 스코프 미지원과
> 2.  이를 통한 의도치 않은 전역 변수 선언

으로 인해 현재는 이를 지원하는 `let`과 `const`로 대체되는 중이다.

---

## **변수 선언의 실행 시점과 변수 호이스팅**

```
console.log(truth); // undefined
var truth;
```

자바스크립트에서는 변수는 런타임이 아니라, 그 이전 단계에서 실행된다.

따라서 **변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 변수 호이스팅이라 한다.**

## **값의 할당**

이에 주의할 것이 값의 할당이다.

```
console.log(v) // undefined
var v = 100;
console.log(v) // 100
```

다음의 첫 번째 결과는 `undefined`이다. 그 이유는 할당은 런타임 이후에 실행되기 때문이다.

그러나 두 번째 결과는 `100`이다. 한 줄씩 런타임 실행을 통하여 **새로운 주소에** 값을 할당했기 때문이다.

> 헷갈리지 말자. 변수에 값을 할당할 때는 기존 `undefined`가 저장된 메모리 공간을 지우고 그 공간에 할당 값을 새롭게 저장하는 게 아니라,
>
> **새로운 메모리 공간을 확보하고 할당 값을 저장하는 것이다.**
> 결국 직접 메모리를 건드리지 않는다는 기존의 원칙을 지킨 것이다!

## 값의 재할당

말 그대로 기존 변수의 값을 다시 할당하는 것이다.
사실 `var`의 경우 처음부터 `undefined`로 값을 초기화하니까 애초부터 재할당이라고 해도 사실은 무방하다.

```
var a = 100
a = 10;
console.log(a) // 10
```

## **그렇다면 어떻게 메모리가 남아돌죠?!**

갑자기 나도 이런 생각이 들었다.
계속해서 값을 재할당한다면, 결국에는 메모리 주소가 꽉차는 것이 아닌가 하고 말이다!

걱정 말자. 자바스크립트에는 `garbage collector`가 있다.
가비지 콜렉터란

> 메모리 공간을 주기적으로 검사하여 사용되지 않는 메모리는 해제하는 기능

이라고 한다.
자바스크립트는 가비지 콜렉터를 내장하고 있는 `managed language`이기에 메모리 누수를 충분히 방지할 수 있다!

> **참고:**
>
> Unmanaged Language vs Managed Language:
>
> - Unmanaged Language: 직접적인 메모리 제어로 최적화 가능. 다만 개발자의 역량에 대한 의존성이 큼
> - Managed Language: 편리성이 높음. 다만 개발자의 관여 권한이 없어 성능에서 100%의 최적화는 불가능.
