# 시작하며 🌈

**제가 아는 바벨은 헬스장 바벨 밖에 없어오 😝**

다들 바쁘시죠?! 사실 바벨...
아직 뭔가 지금 급하게 배울 필요 없는 것 같기는 해요😂😂.
(서로 알겠지만, 다들 바쁘시잖아유!)

그럼에도, 제 발표 들어주셔서 감사하답니다 :)

비록 지금 가야할 길이 멀어서 힘들지만 인생은 그래도 결국 방향이 중요하죠.
아무리 바쁘더라도, 결국 먼 미래에 챙겨야 할 아이라면, 미리 알아두면 또 좋지 않겠어요?!

**마치 여행을 가기 전에, 미리 지역을 알아두는 것과 같은 원리죠.
혹시 알아요?! 언젠가 일본 가려고 계획했는데, 저~ 멀리 영국으로 가서 헤맬지 말이죠!😰**

그렇다면 우리는 일단 **효율성**을 위해 다음을 되짚어 봐야겠네요!

**어이 바 씨, 나 프론트엔드 개발자 될 건데, 같은 방향에서 살아?!**

결국, **프론트엔드 개발에 있어 바벨이 필요하다 = 바벨을 이해할 의향이 생긴다**는 말이 되니까요.

그럼, 시작해봅시다!
이번 긴 이야기는 다음과 같은 방식으로 전개될 거에요.

**1. 바 씨, 당신 뭐하는 녀석이야?! (필요성) 2. 좀 더 딥하게 얘기 나눠볼까?! (주요 과정 및 기능)**

결론이지만, 오늘 우리, 가깝지만 먼 이웃 같은 바 씨랑 찐친 맺어봅시다. 시작하죠!

---

# 1. 바 씨, **당신 뭐하는 녀석이야?!**

## "바 씨, 왜 이름이 바벨이야?"

바벨하면 가장 떠오른 게 어떤 것이셨나요?
저처럼 헬스장 바벨을 떠올렸나요?😅
아마 대다수의 분들께서, **바벨탑**을 떠올리셨을 거라 생각해요.

일단 바벨의 이름에서 바벨이 하는 역할이 정~말 잘 나타나는 것 같아요.
잠시 바벨탑을 살펴볼까요?

**TMI: 바벨탑에 관하여**

또 사람들은 의논하였다.
"어서 도시를 세우고 그 가운데 꼭대기가 하늘에 닿게 탑을 쌓아 우리 이름을 날려 사방으로 흩어지지 않도록 하자."

야훼께서 땅에 내려오시어 사람들이 이렇게 세운 도시와 탑을 보시고 생각하셨다.
"사람들이 한 종족이라 말이 같아서 안 되겠구나.
이것은 사람들이 하려는 일의 시작에 지나지 않겠지.
앞으로 하려고만 하면 못 할 일이 없겠구나.
**당장 땅에 내려가서 사람들이 쓰는 말을 뒤섞어놓아 서로 알아듣지 못하게 해야겠다."**

야훼께서는 사람들을 거기에서 온 땅으로 흩으셨다.
**그리하여 사람들은 도시를 세우던 일을 그만두었다.**
야훼께서 온 세상의 말을 거기에서 뒤섞어놓아 사람들을 온 땅에 흩으셨다고 해서 그 도시의 이름을 바벨이라고 불렀다.

창세기 11장 4~9절 [출처](https://namu.wiki/w/%EB%B0%94%EB%B2%A8%ED%83%91)

네! 결국 바벨이라는 게 언어가 매우 혼재한 곳을 나타내네요.
그리고 놀랍게도, 브라우저도 비슷한 상황이에요. 다음 상황을 떠올려 볼까요?

**개발자**💬:  
**후! 한 달 동안 개고생해서 `ES6`에 맞게 작성했어! 배포만 하면 끝이야!😝**

**전설의 IE**💬:
**오ㅋ 할 수 있으면 해봐ㅋ**

---

결국에 우리 `ES6`와 같은 것들을 **문법**이라고 하죠.
엄연히 **자바스크립트도 언어**이기 때문이고, `ECMAScript`는 하나의 언어에 대한 약속이니까요.

하지만 자바스크립트 문법이 다르면?
특히 브라우저 자바스크립트 엔진이 지원하지 않는 최신 문법이라면?!

![https://mblogthumb-phinf.pstatic.net/MjAxNzEwMjVfMjI5/MDAxNTA4OTIxMzI0NTQ5.Z9aAjyk3nog9dT4t4mAodnIDS1i9yOq07PVoeOSj64cg.MwvwwfN_rx5c80fZTzhwee7u9Vaujvb5Gfq447byhvUg.JPEG.se___ovo/%EC%A7%B1%EA%B5%AC%EC%A7%A42.jpg?type=w800](https://mblogthumb-phinf.pstatic.net/MjAxNzEwMjVfMjI5/MDAxNTA4OTIxMzI0NTQ5.Z9aAjyk3nog9dT4t4mAodnIDS1i9yOq07PVoeOSj64cg.MwvwwfN_rx5c80fZTzhwee7u9Vaujvb5Gfq447byhvUg.JPEG.se___ovo/%EC%A7%B1%EA%B5%AC%EC%A7%A42.jpg?type=w800)

이런 문제를 **크로스 브라우징 이슈**라고 합니다!
결국 서로 다른 브라우저들이 만나면서 생기는 이슈죠!

**바벨이 없는 그 세상에선, 이를 대비하기 위해 여러 가지 문법을 따로 다~ 일일이 작성해야겠죠?**
호오 생각만 해도 아찔하군요.

**하지만 모두가 쓸 수 있는 번역기가 있다면?**
바벨은 이럴 때, 구글 번역기의 역할을 해줘요.
브라우저는 당황스러운 상황에 대비해서 바벨의 도움을 받아요.

**"이거 번역해줘!"
우리, 공식 문서를 볼 때 번역기를 달고 살듯, 브라우저에게 검색기를 주는 건 어떨까요?**

---

# 2. 바벨의 주요 기능

**사실 이 정도만 이해했어도, 바벨은 얼추 설명이 가능한 겁니다.
하지만 당신은 어―썸한 개발자라 더 알고 싶다고요?
그러면, 좀 더 살펴 보죠! 👏**

## 좀 더 딥~하게 얘기 나눠볼까요?!

어썸한 개발자인 당신은 바 씨의 자기소개를 듣기로 했어요.
같이 들어볼까요?

Babel is a toolchain that is **mainly used to convert ECMAScript 2015+ code into a backwards compatible version of JavaScript in current and older browsers or environments.** Here are the main things Babel can do for you:

음... 쉽게 말하자면, 핵심은 **`compatible`** 이겠네요!
**결국 옛날 브라우저 환경과 `ES2015` 이후의 코드들을 호환 가능한 버전으로 변환 시켜준다는 것이겠어요!**

### 추가로 설명된 주요 기능은 다음과 같아요.

- **Transform syntax**
- **Polyfill** features that are missing in your target environment
  (through a third-party polyfill such as [core-js](https://github.com/zloirock/core-js))
- **Source code transformations** (codemods)

오! 브라우저가 이해하지 못한 코드와 문법은 쉽게 **transformation** 해주고,
환경에서 지원되지 않는 **폴리필**도 지원해주네요!

> **`Polyfill` `Transformation`을 모르셨다고요? 괜찮아요. 저도 잘 몰라요. 😝
> 그럼 우리 주요 기능인 이 두 가지에 대해 이야기를 나눠 보죠!**

## `Transformation`

일단 바 씨가 하는 일이 뭐랬죠?! 자바스크립트 **컴파일러**죠!

> "**순간, 자바스크립트는 인터프리터 언어 아닌가요?!라는 드셨을 거 같아요!
> 이는 [이 글](https://hashcode.co.kr/questions/7560/javascript-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EC%96%B8%EC%96%B4%EC%9D%B8%EA%B0%80%EC%9A%94-%EC%9D%B8%ED%84%B0%ED%94%84%EB%A6%AC%ED%84%B0-%EC%96%B8%EC%96%B4%EC%9D%B8%EA%B0%80%EC%9A%94)을 읽는다면 이해하실 수 있을 거에요!
> 하지만 우리의 여정은 길어서, 잠시 생략하도록 하죠.**"

결국 바벨은 다음과 같은 컴파일 과정을 거치게 된다고 합니다!

**참고로 이는, 모던 컴파일러 대부분이 자세한 건 다르더라도, 큰 부분에서는 비슷한 과정을 가진다고 하니, 알아두면 일석이조입니다! (특히 바벨만큼은, 이런 방식이겠죠?!)**

### 1. 파싱

어떤 원본의 코드를 더욱 추상화된 표현으로 바꿔준다고 해요.
여기서는 크게 **2가지**로 나뉩니다!

1. **어휘 분석(Lexical Analysis)**

   raw한 코드를 렉서(토큰화기)를 통해 토큰으로 잘게 분할을 시켜줘요!
   쉽게 말해서, 다음과 같은 예시를 들어볼 게요.

   1. 나 원시 코드. 브라우저 애한테 "엄마, 아빠 사랑해요!"를 알려주고 싶어!
   2. 일단 각각의 의미를 담고 있는 "엄마", "아빠", "사랑", "해요"로 나눠서 알려주자!

1. **구문 분석(Syntactic Analysis)**

   그럼 이제 얘는, 토큰들을 갖고 이제 어떤 깊이를 가진 객체로 만들어줘요. 즉 방금 예시로 하면

   **1. 아, 이렇게 알려주면 엄마, 아빠 중 둘 중 누구를 사랑하는 줄 모를 수도 있겠다!
   (엄마! 아빠 사랑해요?!로 해석될 수 있음) 2. (엄마+아빠) 같은 깊이로 표현 → 사랑해요!라고 말하면 되겠다! 3. 브라우저: 아 둘 다 사랑한다는 거구나!**

- **추상화되지 않은 날것의 과정을 알고 싶나요?! 다음을 해제하세요!**

  ```jsx
  /* (add 2 (subtract 4 2))라는 게 있다면 다음과 같습니다!
   * 토크나이저에 의해 분석된 토큰은 다음과 같아요!
   *   [
   *     { type: 'paren',  value: '('        },
   *     { type: 'name',   value: 'add'      },
   *     { type: 'number', value: '2'        },
   *     { type: 'paren',  value: '('        },
   *     { type: 'name',   value: 'subtract' },
   *     { type: 'number', value: '4'        },
   *     { type: 'number', value: '2'        },
   *     { type: 'paren',  value: ')'        },
   *     { type: 'paren',  value: ')'        },
   *   ]
   *
   * And an Abstract Syntax Tree (AST) might look like this:
   *
   *   {
   *     type: 'Program',
   *     body: [{
   *       type: 'CallExpression',
   *       name: 'add',
   *       params: [{
   *         type: 'NumberLiteral',
   *         value: '2',
   *       }, {
   *         type: 'CallExpression',
   *         name: 'subtract',
   *         params: [{
   *           type: 'NumberLiteral',
   *           value: '4',
   *         }, {
   *           type: 'NumberLiteral',
   *           value: '2',
   *         }]
   *       }]
   *     }]
   *   }
   */
  ```

### 2. `Transformation` (찾았다, 요놈!)

이 과정에서는 컴파일러가 추상화된 표현을 갖고 원하는 대로 조작하고 가져온다고 해요!
이 과정에서 아까 구문 분석한 결과인 `AST`가 사용되는데요! 이 친구의 특징이 뭐였죠?!

**구문에 따라 깊이가 반영된 거죠?!**

**그래서 우리가 배운, 전위 순회가 사용된다고 합니다 :) (배운 보람이 있어오!👏)**

- **참고로 이러한 전위 순회를 통한 변환 최적화를 "방문"이라는 말로 표현하네요.**

  ```jsx
  * So for the above AST we would go:
   *
   *   1. Program - Starting at the top level of the AST
   *   2. CallExpression (add) - Moving to the first element of the Program's body
   *   3. NumberLiteral (2) - Moving to the first element of CallExpression's params
   *   4. CallExpression (subtract) - Moving to the second element of CallExpression's params
   *   5. NumberLiteral (4) - Moving to the first element of CallExpression's params
   *   6. NumberLiteral (2) - Moving to the second element of CallExpression's params
   *
   * If we were manipulating this AST directly, instead of creating a separate AST,
   * we would likely introduce all sorts of abstractions here. But just visiting
   * each node in the tree is enough for what we're trying to do.
   *
   * The reason I use the word "visiting" is because there is this pattern of how
   * to represent operations on elements of an object structure.
   *
   * Visitors
   * --------
   *
   * The basic idea here is that we are going to create a “visitor” object that
   * has methods that will accept different node types.
   *
   *   var visitor = {
   *     NumberLiteral() {},
   *     CallExpression() {},
   *   };
   *
   * When we traverse our AST, we will call the methods on this visitor whenever we
   * "enter" a node of a matching type.
   *
   * In order to make this useful we will also pass the node and a reference to
   * the parent node.
   *
   *   var visitor = {
   *     NumberLiteral(node, parent) {},
   *     CallExpression(node, parent) {},
   *   };
   *
   * However, there also exists the possibility of calling things on "exit". Imagine
   * our tree structure from before in list form:
   *
   *   - Program
   *     - CallExpression
   *       - NumberLiteral
   *       - CallExpression
   *         - NumberLiteral
   *         - NumberLiteral
   *
   * As we traverse down, we're going to reach branches with dead ends. As we
   * finish each branch of the tree we "exit" it. So going down the tree we
   * "enter" each node, and going back up we "exit".
   *
   *   -> Program (enter)
   *     -> CallExpression (enter)
   *       -> Number Literal (enter)
   *       <- Number Literal (exit)
   *       -> Call Expression (enter)
   *          -> Number Literal (enter)
   *          <- Number Literal (exit)
   *          -> Number Literal (enter)
   *          <- Number Literal (exit)
   *       <- CallExpression (exit)
   *     <- CallExpression (exit)
   *   <- Program (exit)
   *
   * In order to support that, the final form of our visitor will look like this:
   *
   *   var visitor = {
   *     NumberLiteral: {
   *       enter(node, parent) {},
   *       exit(node, parent) {},
   *     }
   *   };
   */
  ```

**Q.** **자...** **잠깐 멈춰!🖐🏻 그래서, 어떻게 변환한다는 건데?!**

이때 활약하는 애가 있어요. 바로 플러그인이라는 애에요!
이 친구를 꽂아 두기만 하면 현재 단계에서, 순회할 때마다 플러그인을 참조하며 이건 이렇게 처리해야 하는 거야!라고 알려준다고 합니다. 💪🏻

### 3. 코드 생성(Code Generation)

우리는 이제 다시 코드로 만들어 줄 거에요. 코드를 받았으니, 이제는 코드로 리턴한다!
(여기서 알 수 있는 게, 결국 **컴파일러도 하나의 함수의 형태인 거죠!**)

일단 여기서부터는 각 컴파일러마다 다르지만... 일단 바벨에서 추천한 문서를 보면

1. 여기서 도착한 `AST`는 변환과정을 통해 어떻게 처리하라고 기술되어 있을 거에요!
2. 결국 이에 따라서 재귀적으로 자기를 호출하면서 노드를 인쇄시켜요!
3. 결과적으로 코드는 생성되어 반환되고, `AST`와 `stringify` 됐던 코드는 없어지는 거에요

**와우! 여기까지 오셨다니, 이제 정말 바벨에 대해 깊이 이해하게 된 거에요!**

---

## `Polyfill`

후! 드디어 바벨 컴파일러 동작 과정을 다 살펴봤네유.😂👏👏
이제는 훨씬 쉬워졌어요. 이 친구는 간단해요.

`Promise`이라는 객체를 떠올려 봅시다. 이 친구는 `ES6`에는 있는데요, 이하 버전에서는 없습니다.
그렇다면 이런 친구를 만날 때, 또 다시 브라우저는 멍~해지겠죠?!

이럴 때 폴리필이 쓰이는 거에요. 쉽게 말해서 **음...
번역기에 과거 옛날 언어(ex: ㆆ) 라던지, 신조어(ex: 민초단) 등을 넣어주는 거죠?!**

예컨대 사람들이 직접 만들어낸 `replaceAll` 폴리필을 살펴볼까요?!
(참고로 replaceAll도 아직 일부 브라우저들에서 제대로 지원되지 않는 최신 메소드입니다!)

```jsx
String.prototype.replaceAll = function (from, to) {
  if (from instanceof RegExp)
    if (!from.flags.includes)
      throw new TypeError("replaceAll must be called with a global RegExp");
    else return this.replace(from, to);
  else
    return this.replace(
      new RegExp(from.replace(/[\\^$*+?.():=!|{},\[\]]/g, "\\$&"), "g"),
      to
    );
};
```

예전에는 이를 `@babel/polyfill`으로 처리가 가능했어요.

얘 안에는 `regenerator runtime`와 `core-js`가 들어있었는데, 이제는 직접 얘네 둘을 포함시키도록 하게 했다네요! (7.4.0 버전 이후로 deprecated)

## 기타

### `plugin`

아까 변환에서 썼던 애죠? 옵션을 설정해주는 애에요! 참고로 여러 개를 쓸 수 있어요.
하지만 이 친구 특이한 게, 뒤에서부터 순서대로 꽂아서 변환을 처리해줄 거에요.
**따라서 다음 순서에 유념해서 꽂아 두자구요!**

우리 [바 씨 멀티탭에 꽂을 수 있는 플러그인](https://babeljs.io/docs/en/plugins-list)은 다음과 같네요!

1. 플러그인은 사전 설정보다 먼저 실행됩니다.
2. 플러그인 순서는 처음부터 끝까지입니다.
3. 사전 설정 순서가 반대입니다(마지막에서 먼저). -공식 문서 (플러그인) 중

```jsx
{
  "plugins": ["babel-plugin-myPlugin", "@babel/plugin-transform-runtime"]
}
```

### `preset`

**얘는 플러그인 여러 개 꽂아 놓은 멀티탭 같은 느낌이에요.** 일일이 다~설정하면 너무 힘들잖아요?! 하나라도 빠지면 또 고생하고 말이죠.

따라서 편의를 위해 이런 건 보통 다 필요하니까~ 넣어~하는 만능 재주꾼 같은 느낌이랍니다!
