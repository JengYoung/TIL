## **원시 값과 객체의 비교**

자바스크립트가 제공하는 데이터 타입들은 크게 **2가지**로 구분 가능하다.

> - 원시 타입 : 변경 불가능한 값
> - 객체 타입 : 변경 가능한 값

원시값을 변수에 할당한다면, 변수는 실제 값이 저장된다.

|                  |                   원시타입                   |                 객체 타입                 |
| :--------------: | :------------------------------------------: | :---------------------------------------: |
|  변수에 할당 시  |                 실제 값 저장                 |               참조 값 저장                |
| 다른 변수에 할당 | 원본의 원시 값 복사되어 전달 (call by value) | 참조 값 복사되어 전달 (call by reference) |

---

## **원시값**

> **값을 변경할 수 없다!**

변수는 언제든지 재할당을 통해 변수 값을 변경 가능하지만, 원시 값 자체는 변경이 불가능하다. **즉 읽기 전용 값인 것이다.**

- **불변성**  
  원시 값을 직접 변경할 수 없는 특성.  
  대신 변수 값을 바꾸기 위해서는 메모리 공간을 새로 확보하여 재할당한 값을 저장 후, 참조하던 주소를 변경하는 과정을 거침. >불변성을 갖는 원시 값을 할당한 변수는 **재할당 이외에 변수 값을 변경할 방법이 없다.**

### **문자열과 불변성**

JavaScript는 문자열 타입을 제공한다.
이때 문자열은

> 1. 유사 배열 객체이면서
> 2. 이터러블이므로

배열과 비슷하게 문자에 각각 접근할 수 있다.

```
var str = 'string';
console.log(str[0]);
```

다만 문자열 자체는 원시값이기 때문에 변경할 수 없다. 따라서 다음은 불가능하다.

```
str[0] = 'S' // 문자열은 원시값이므로 변경할 수 없다.
console.log(str); // string
```

이 부분은 헷갈릴 수 있으니 좀 더 부연설명하자면, **원시값을 객체처럼 사용하면 원시값을 감싸는 래퍼 객체로 자동변환된다고 한다!**

### **값에 의한 전달**

```
let val = 80;
let copy = val;

val = 100;
console.log(copy); // 80
```

변수에 변수를 할당했을 때, **원시 값을 갖는 변수를 할당하면 할당받는 변수에는 할당되는 변수의 원시값이 <U>복사</u>되어 전달**되는데, 이를 값에 의한 전달이라 한다.

> 정확히 말하자면, 식별자는 메모리 주소를 기억하는 것이기에, 원시값을 복사, 저장한 주소가 전달된다.

---

<br/>

## **객체**

참조 타입의 변경 가능한 값.  
객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근할 시 **참조값에 접근**

원시 값과 가장 구별되는 특징은 바로

> **객체는 재할당 없이 객체를 직접 변경할 수 있다.**

### **Why?**

객체의 생성 및 관리 방식은 자체는 매우 복잡하며 비용이 많이 드는 방식이기 때문이다.  
결과적으로 성능을 향상시키기 위해 복사 및 생성 비용을 절약한다.

### **문제점**

> 위와 같은 특성으로 인해 객체는 여러 식별자가 같이 공유할 수 있다는 한계점이 생기게 된다.

다음 예제를 살펴 보자.

```
const person = {
    name: 'Jaeyoung'
};

const copy = person; // 같은 객체를 가리킴.

copy.name = 'Hwang'
person.age = '28';

console.log(person); //{ name: 'Jaeyoung', age: '28' }
console.log(copy); //{ name: 'Jaeyoung',  age: '28' }
```

**참조에 의한 전달**

1. 객체를 가리키는 변수를 다른 변수에 할당할 시 원본의 참조 값이 복사되어 전달
2. 원본의 참조값에는 객체를 가리키는 메모리 주소가 있으므로 같은 메모리 주소를 가리킴
3. 결과적으로 두 개의 식별자가 하나의 객체를 공유

> ### **그렇다면 같은 게 아닌가?**
>
> 생각해 보면 결국 참조에 의한 전달 역시 메모리 주소를 전달한다는 면에서 **값에 의한 전달**인 것이다.

다만 객체와 같은 참조값을 가리키고 있다면, 그 객체는 재할당이 아닌 기존 값을 변경한다는 점이 차이가 있을 뿐이다.
