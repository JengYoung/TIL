# 함수 합성 관점에서의 Promise ?

비동기 상황에서 함수 합성을 안전하게 지원하는 게 `Promise` 객체죠. 즉, 모나드라고도 설명을 하는데요!

# 모나드?!

함수 합성에 대해서 일단 알아보면, 우리는 f(g(x))의 방식으로 함수를 합성하죠?!

그런데 생각해봐요. 이게 몇 개가 반복되면, 사실상 콜백지옥처럼 엄청나게 복잡해지죠.

따라서 연속적으로 함수가 실행되고 합성될 때 안전하게 사용할 수 있게 하는 게 모나드에요.

자바스크립트는 타입을 집중해서 사용하는 언어는 아니죠.

따라서 자바스크립트는 모나드를 직접적으로 이용, 정의하지는 않게 돼요.

자바스크립트에서 모나드가 중요하지는 않지만, **안전한 함수형 프로그래밍에 있어서는 꼭 빼놓을 수 없는 개념!**

동적 함수형 프로그래밍을 할 때, 모나드 개념을 중시하거나 이야기하지는 않아요. 모나드라는 값이나 객체가 특정 되지 않기 때문이에요.

`**Array` `Promise`를 통해 함수 합성에서의 안전성, 응용력 등을 알 수 있어요!\*\*

# In JavaScript

```jsx
const g = (a) => a + 1;
const f = (a) => a * a;
log(f(g(1)));
log(g(f(1)));
// 이것이 가능한 이유는 실제로 유의미한 값.

log(f(g(undefined))); // 외부에게 영향을 주고 싶지 않은 데이터(ex: 초기화)라 하더라도 연산이 되므로 불안전함.
```

이런 상황에서 해결해줄 수 있는 게 모나드에요!

```jsx
// []:모나드
[1]
  .map(g)
  .map(f)
  .forEach((r) => log(r));
```

`Array`가 굳이 필요없지 않나! 실제로 배열을 출력시키지는 않으며, 우리가 가장 원하는 건 배열에 담긴 값이기 때문이다.

# 결국 Promise도 모나드와 비슷.

결국 안전한 값이다!라는 것을 미리 밝혀주면서, 있든 없든 일단 값이라는 것을 인지시켜줌으로써 안전하게 처리하게 해준다.

# 모나드의 개념에 집중하지 마라!

Array 값 개수가 몇 개일지 모르고, 중간에 필터로 인해 크기가 작아질 수 있는 상황에서, 어떤 상황에서든지 안전한 함수 합성을 위한 도구.

프로미스는 합성 관점에서 봤을 때

1. 비동기 상황, 즉 얼마만큼의 딜레이가 필요한지에 따라서도 적절히 함수를 합성,
