# 이 글을 쓰게 된 배경.

최근에 회사 애플리케이션을 새로 구축하면서 아키텍처에 관심이 가게 됐고, 그래서 모노레포에 대해 얼핏 공부하기는 했다.

그런데, 꽤나 난이도가 있어 보였고, 아직은 애플리케이션이 작아서 모노레포를 고민하다 포기했다.

그러나 최근에 주변 개발자 친구들과 얘기한 결과... 다른 회사들은 모노레포로 구축되어 있는 곳이 많더라.

> 아, 비록 혼자서 일을 하고 있지만 이렇게 도태되면 안되겠구나. 라고 생각했다.
> 결국 이를 공부하지 않고 '회사에서 배우지 않았기 때문에'는 변명이기에.

따라서 이를 제대로 고민하고자 이 글로 정리한다.

<br/>

---

# "모노레포, 그게 뭔데."

## 모노레포의 등장은 어떻게 시작되었을까.

일단 모노 레포라는 단어의 피상적인 의미를 추출해보자.

> "Mono-repo = Mono(Single) + Repo(Repository) = 단일 레포지토리"

따라서 단일 코드 저장소라는 하나의 개념에서 출발한다.

솔직히 나는 이해가 되지 않았다. 왜 단일 코드 저장소가 대두된 것인가?  
따지고 보면 이는 응집도 있게 관리하는 원칙에 반하는 것 아닐까. 고로 코드 관리의 복잡성을 높이지 않겠는가?  

따라서 이를 다음 [Naver D2 문서](https://d2.naver.com/helloworld/0923884#ch1)를 참조하며 공부하기 시작했다.


<br/>

---


### 태초에, 모놀리식 애플리케이션이 있었나니.

쉽게 말하자면, 모듈화를 하지 않고 평소에 그냥 쉽게 하나의 애플리케이션을 짜임새 있게 구성하는 것이 모놀리식이다.
![Naver D2 출처 - Monolith App Repo](https://d2.naver.com/content/images/2022/04/0a710ba9-7e47-1064-817f-86e0ae025d1b.png)

솔직히 이게 나쁜 것이 절대 아님을 말한다. 오히려 작은 프로젝트는 모놀리식이 적합하다.

> 변명이자면... 모놀리식으로 다시 리빌딩하는 나의 선택은 분명 옳았다... 껄껄...

그러나, 나중에 방대한 팀으로 작업을 한다고 생각해보자. 그렇다. 전쟁의 서막이 이렇게 시작된다.

<br/>

---

### "소리 없는 전쟁의 시작, 버전 관리"

> **"이 드라마는... 큰 회사를 다녀보지 않은 제 상상으로 구성되었습니다."**


콘텐츠 팀의 A팀장과 결제 팀의 B팀장이 있다고 가정한다.

A팀장은 뭔가 매우 기분이 안 좋아 보인다. 그 이유를 들어 보자.

> **A팀장:** B팀장님, a 패키지 버전 올리는 게 어때요? 이번에 번들 축소도 되고, 최적화를 지원하는 기능들이 많이 생겼는데 말이죠.
>
> **B팀장:** 음... 글쎄요. 아직은 우리 콘텐츠팀에서 개발해야 하는 것도 많은데, 버전까지 올리려 하니 이는 생산성에서 좀 문제가 발생할 것 같아요. 아직은 저희 측에서 필요한 것도 아닌 것 같고요.
>
> **A팀장:** 아... 그렇다면 **아예 모듈을 분리**하는 건 어떨까요? 우리 쪽에서는 어제 회의에서 대표님께서 말씀하시길 현재 성능 최적화가 절실히 필요한 상황인지라.
>
> **B팀장:** 그렇기에는... **패키지나 컴포넌트 측에서 반복되는 코드라던지, 컨벤션이 통일되지 않는 문제가 존재하지 않나요? 그것 또한 나중에 일관성 있게 관리하기 어렵구요.** 미안해요. 혹시 1달만 더 기다려줄 수 있어요? 이번 스프린트 끝나면 우리 같이 올리는 방식으로 검토해보죠.
> 
> **A팀장:** ... (우리 성과 챙기기도 급한데, 이걸 납득해 말아...)


~~나도 낭만 적인 대화를 꿈꾼 적이 있다.~~ 다른 개발자들과 함께 협의(a.k.a 논쟁)하며 더 나은 방향으로 애플리케이션을 develop하다니, 너무 환상적이지 않은가...! 

> 자, 헛소리는 각설하고.  

두 개발자의 주장은 매우 합리적이다. 각자의 위치에서, 현재 각 팀의 KPI에 따라 필요한 주장을 했기 때문이다.

그러나 이것이 과연 최선의 결과에 도달했는가? 그렇지 않다. 결국 A팀은 B팀을 위해 양보를 해야만 하는 상황이 온 것이다.

따라서 개발자들은 고민하기 시작했다.

+ "모듈을 적절히 분리하면서, 쉽게 관리할 수 있는 방법이 없을까?"
+ "테스트, 빌드, 배포 과정 역시 쉽게 할 수 없을까?"
+ "코드를 일관성 있게 관리할 수 없을까?"

이러한 관점에서, 모노레포라는 시도가 시작되었다.
> **"반가워요. 모노레포의 세계에 오신 개발자들이여"**

## 환영합니다, 모노레포에 오신 것을.
### 같은 저장소, 다른 모듈

모노레포는 모듈성을 지향한다.

즉 독립성을 지닌 프로젝트는 독립적으로 관리해야 한다는 응집도 높은 아키텍처를 지향한다.

그러나, **저장소는 같아야 한다는 원칙**을 고수한다.

왜? 의존성이 존재하거나 같은 제품군에 대한 관계성을 명확히 하기 때문이다. 결과적으로 대규모 프로젝트에서의 관리를 용이하게 하는 것이다.

### 패키지 생성이 이렇게 간단해?

원래 분리된 레포지토리였다면, `import` 하는 데 있어 이전에 패키지 저장소에 등록하는 귀찮은 절차들이 수반된다.

하지만 모노레포는 그냥 자신의 레포지토리에 있으니, 이런 부수 절차들을 고려할 필요가 없다.

### 의존성 관리는 쉽게! 🙇🏻‍♂️

이미 의존성 패키지가 같은 저장소에 존재하니, 버전이 지정된 패키지를 따로 npm에 올릴 이유가 없다!


### 관리 포인트가 단축된다!

이건 프로젝트 관리해본 사람이라면 백 번 공감하는데, 한 곳에 모인 것이 확실히 분산된 것보다 개발 환경을 관리하는 데 있어 용이하다.

### 일관된 개발 경험

애플리케이션을 구축함에 있어 컨벤션 등에 있어 일관성을 유지하기 편하고, 손 쉽게 다른 팀 애플리케이션에 기여가 가능하다.

나아가 변경 사항 역시 테스트하기 용이해진다.

### 커밋에 따른 변화 확인 용이

결국 어떤 문제가 발생하면 이슈를 트래킹해야 하는데, 이 역시 관리 포인트가 한 곳에 존재하기 때문에 변경사항에 있어 전 조직적인 관리가 용이해진다.

### 리팩터링 비용 감소

이 역시 결국 테스트의 관점과 비슷한데, 리팩터링 후 작동 여부를 손쉽게 테스트할 수 있기에 시간적인 측면에서 생산성을 줄 수 있다.

## 모노레포, 괜찮은 것 맞아?

모든 것을 한 곳에서 관리하면, 코드 변경에 대한 안정성이 의심될 수 있다.

그러나 안심하자. `CodeOwners`라는 깃헙 기능 등을 통해 모노레포에 대한 안정성을 높일 수 있다.

### '안전'하기는한데, '완전'한 아키텍처는 아니다.

항상 개발을 하면서 시니어들도 실수하는 부분이 있다. 

> **요즘 A가 좋다던데, 이거 할까요?**

모노레포도 이런 방식으로 하다가 ~~망하는~~ 회사 여럿 봤다.

일단 자신의 회사 애플리케이션이 다음 요건에 충족하는지부터 잘 살펴보자. 

+ 합치려는 레포지토리가 유사한 프로덕트인가?
+ 변화가 쉽게 다른 프로젝트에서 보여야 하는가?
+ 공통 기능을 재사용하는가?
+ 유사한 DevOps로 구성되어 있는가?
+ 상위 애플리케이션을 일종의 플러그인으로 확장시켜야 하는가?

### 모노레포, 너무 느린데...

모노레포는 다양한 레포지토리를 한 곳에 모아두었기 때문에 속도 최적화가 무엇보다 중요하다. 결국 어떻게 의존성을 고려하며 병렬적으로 잘 전개하느냐가 포인트.

다음 요소들을 충분히 검토하며 개발을 진행해야 개발 만족도를 높일 수 있다 :)

+ 로컬 캐싱: 같은 것은 한 번만 캐싱해서 빌드하고 테스트하자.

+ 병렬적인 작업: 직렬인 빌드와 테스트 금지. 순서를 해치지 않는 선에서 병렬로 하자.

+ 분산 캐싱: 다양한 환경에서의 캐시를 공유하고, 고려해야 한다. 만약 이를 고려하지 않고 CI가 중복된 것을 빌드하고 테스트하면 속도가 느려진다.

+ 분산 작업: 단일 시스템에서 여러 시스템에 명령을 전달해야 한다.

+ 변화에 민감한 프로젝트 우선: 의존성 높은 항목만 빌드/테스트를 진행하고, 이후의 것들을 병렬적으로 진행하면 좋다.

### 모노레포, 관리 너무 귀찮은데...

다음을 고려한다면, 개발자들 간에 충분히 관리에 대한 보람을 느낄 수 있다.

+ 코드 공유
+ 일관성 있는 도구, 일관성 있는 경험
+ 겹치는 코드로 인한 초기 생성 용이
+ 프로젝트 제약 명시에 대한 가시성 높음
+ 워크 스페이스 의존성 분석 용이
+ 의존성 그래프 시각화 용이


<br/>

--- 

## 주요 관련 패키지

모노레포 구성에 있어 다음 패키지들이 인기가 많다.

+ `Lerna`
+ `Yarn`
+ `npm`
+ `pnpm`
+ `Nx`


<br/>

---

# 👏🏻 마치며

아무래도 본인과 다른 이들의 경험만으로 글을 쓰기에는 너무나 깊이가 부족하고, 요새 활발히 많은 회사에서 시도하는 아키텍처라, 좀 더 공신력 있는 네이버 D2의 힘을 전적으로 빌렸다.

그러나 나름대로 충분히 비판적인 사고를 하며 썼기에, 나름 글에 대한 퀄리티는 만족한다 :)

> 이제 모노레포 연습하러 가봐야지. Hello, Mono-repo! 🥰

<br/>

---

# 참고자료
[Naver D2 - 모던 프론트엔드 프로젝트 구성 기법 - 모노레포 개념 편](https://d2.naver.com/helloworld/0923884#ch1)