# 리스코프 치환 원칙

이전에 쓰인 글은 다음과 같이 서술되었다.

> - 자식 클래스는 언제나 자신의 부모 클래스를 대체할 수 있다.
> - 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 계획대로 잘 작동해야 한다.
> - 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행하도록 한다.

사실 이 말이 너무 이해가 되지 않아서 이번에 글을 정리한 감도 있다.
이것은 어떻게 설명해야 할까?

## 자식 클래스는 부모 클래스를 대체할 수 있어야 한다

이 말이 핵심이다.  
자식 클래스는 부모 클래스를 상속받았기 때문에, 로직에 있어서 서로 다른 결과를 도출하면 안 된다는 것을 의미한다.

### 예제: 개발자 D, 프린터를 개발하다

단일 책임의 원칙, 개방 폐쇄 원칙을 거쳐 우리의 만능 개발자가 되어가는 D는, 오늘 프린터를 만들어야 한다. 리드 개발자는 여태까지 고생했던 D가 미안했는지, 과제를 던지며 이렇게 말했다.

> 그냥 콘솔에다 찍으면 돼요! 매우 간단하죠? ^^

네! 정말 간단합니다!  
호다닥 구현하는 개발자 D.


```js
class Printer {
  cosntructor(msg) {
    this.msg = msg;
  }

  print() {
    console.log(this.msg)
  }
}
```

이제 개발자 D에겐 이정도는 껌이다 😉

#### 엇! 여러 메시지를 출력해야 한대요!

귀찮았지만, 이마저도 쉬웠다.  
왜? 개발자 D에게는 상.속.이 있기 때문이다. 쿠쿡...

```js
class MultipleMessagePrinter extends Printer {
  constructor(msg) {
    this.msg = msg;
  }

  print() {
    this.msg.forEach((m) => {
      console.log(m)
    })
  }
}
```

#### 개발자 D씨! 그런데 화면에서도 보여야 한대요!

오호! 그렇군요.
매우 간단하다. alert()를 위에서 구현한 후 아래에서도 멀티플하게 보여야 한다면 되니까!



```js
class Printer {
  // ...
  alertMessage() {
    alert(this.msg);
  }
}

class MultipleMessagePrinter extends Printer() {
  alertMessage() {
    alert(this.msg.forEach(m => alert(m)))
  }
}
```

오늘도 정말 쉽군!하며 자랑스레 사수에게 "다했습니다."하고 보고했다.

#### 개발자 D씨! UX 생각해야죠. UX! 😡🔥

갑자기 사수는 결과물을 받아보더니, 한 숨을 쉬면서 위와 같이 말했다.  
멀티라인으로 구현한 건 잘 했는데, 왜 메시지는 하나하나 나오게 했냐고 다그쳤다.  

그래서 다시 만들라는 요구를 받은 D씨. 오늘따라 코드가 치기가 싫다.

> 하... 회사 그만 둘까...^^
> 역시 회사 생활은 녹록지 않다.

---


## 원인: 인자의 기대치를 고려하지 않았다.

사실 이 예제는 완전히 적절하지는 않다. 사실 저것을 배열의 상태로도 구현할 수 있기 때문이다.  
또한 알림은 엄연히 프린터와 다른 기능이다. 그렇지만 예제라는 특성에서 용인된다고 치자.  

> 이때, `MultipleMessagePrinter`은 `Printer`을 대체하지 못한다.
> 이는 리스코프 치환의 원칙을 위배한다.

이 문제의 핵심은 바로, `params`에 대한 기대치가 발생했다는 것이다.
상위의 인터페이스와 하위의 인터페이스가 엄연히 다르다. 따라서 이에 대한 고려를 했어야 했다.  
어떻게 하냐고 묻는다면 다음과 같이 할 수 있겠다.

```ts
class MultipleMessagePrinter extends Printer {
  constructor(msg: string | Array<string>) {
    super(msg);
  }

  print() {
    if (this.msg?.constructor?.name === 'Array') {
      alert(this.msg.forEach(m => alert(m)));
      return;
    }

    super.print()
  }

  alertMessage() {
    if (this.msg?.constructor?.name === 'Array') {
      alert(this.msg.join('\n'));
      return;
    }

    super.alertMessage()
  }
}
```

기본 상속을 따라가되, 타입에 따라서 분기처리를 해주니, 이제는 더 완전한 상속이 가능하게 됐다.  
또한, 유연함을 획득했기 때문에 마치 `D3`와 같은 느낌이 들기도 한다.  
(실제로 나는 `D3`의 구현 스펙을 보았을 때, 잘 설계했다고 느껴졌다. 깔끔한 설계와 더불어, 대개의 타입에 있어서 유연한 대응이 가능하다니!)

# 마치며

사실 이 예제를 떠올리는 데만 해도 적합성만 따지다 1시간 반이 흘렀다.  
뭐든지 새로 부딪히면서 익힌다는 것은 정말 많은 시간을 들이게 되고, 또한 이러한 철학은 FP에 가까운 자바스크립트의 유저로서 **변명이 아닌 "좋은 코드가 무엇인지"** 를 고민하게 했다.

