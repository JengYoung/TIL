# 데코레이터 패턴

주어진 상황 및 용도에 따라 어떤 객체에 책임(기능)을 동적으로 추가하는 패턴이다.  
핵심은 바로, 객체를 바꾸지 않고 그 기능을 늘리는 기법이라는 것이다.
단지 데코레이터라는 말 그대로 기존 객체의 추가적인 장식에 지나지 않다.  
기본 기능을 바꾸는 건 개방-폐쇄의 원칙에 어긋나므로 클래스를 하나 만들어주고 추가할 수 있는 기능들을 추가하기 편하도록 설계하는 방식이다.  

어떻게 보면 확장에서 사용하는 패턴이며, 단지 확장적으로 설계한다는 측면만 따지고 보면 사실 다른 디자인 패턴의 확장 방식과 많이 겹치는 경향이 있다.  
다만 객체를 생성하여 이러한 확장성을 간편하게 핸들링하는 방식이라고 생각하며 편하지 않을까.

## 장단점

### 장점
1. Decorated Object의 개방-폐쇄 원칙을 따를 수 있다. 단지 객체 하나 추가해서 행동을 확장시킬 수 있다.
2. 책임을 Decorator에 위임하면서 실행 중에 새로운 행동을 추가할 수 있다.

### 단점

- 객체들이 쓸 데 없이 많이 추가되어 복잡성을 야기한다. (이게 제일 크다.)

## TDD 작성 방법

1. Decorated Object의 모의체를 만든다.
2. 에러가 Decorated Object → Decorator → Call Stack을 타고 Pass Through(그저 성공이 될 수 있도록 기능 추가하여 성공하는 것)되는지 테스트로 확인한다.

3. 아무것도 하지 않는 장식자를 만들고, 테스트하여 실패를 확인한다.
4. Pass Through 기능을 장식자에 추가하면 테스트는 성공한다.

5. Decorator가 호출부에 성공 신호를 잘 넘기는지 테스트로 확인한다.
6. 실패한 테스트는 성공하게끔 코드를 작성한다.

7. Decorator의 기능을 추가한다.
8. Decorator의 일반화 문제를 고민한다.

## 주의사항

Decorated Object 자체에 결함이 있다면, 코드가 잘못되지 않았는데 유지보수해야 할 상황이 발생한다.
Decorated Object를 노출하지 말고, 이를 모형으로 대체해야 한다.  
이를 통해 실제 객체보다 확실한 에러를 만들 수 있다.