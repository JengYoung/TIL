# 멍키패칭(메서드 빌림)

다른 객체의 함수를 빌림으로써 반복되는 로직의 재사용성을 늘리는 기법이다.

| <div style="width:160px;">SOLID 원칙</div> | 설명 |
|:---:|:---|
| 단일 책임 | 기증받은 기능 다발이 단일 책임으로 이루어진다 해도 빌림 자체로 빌리는 객체에 책임을 전가하는 게 아닌가 하는 점에서 논란의 여지는 있을 수 있다. 하지만 그런 식으로 생각하면 애스팩트 역시 책임을 더하는 건 마찬가지라서 결국 어불성설이다. |
| 개방/폐쇄 | 멍키 패칭을 분별 있게 잘 쓰면 개방/폐쇄 원칙을 어길 일은 없다.| 
| 리스코프 치환 | 빌린 함수가 새 집과 옛집에서 그 의미가 같다면 문제없다.
| 인터페이스 분리 | 인터페이스 분리 원칙은 멍키 패칭이 추구하는 바로 그 자체다! |
| 의존성 역전 | 의존성은 보통 빌려주는 객체 또는 빌리는 객체 어느 쪽에도 주입될 수 있다. |
| DRY(반복하지 마라) | 창의적이고 책임감 있는 개발자의 손을 거친다면 멍키 패칭은 DRY한 코드를 유지하는 데 도움이 많이 될 것이다. |

## 주의 사항

대개 객체는 `this`를 통해 프로퍼티와 메서드를 관리한다.  
이때, 메서드 빌림 기법은 이러한 `this`가 바뀐다는 점에서 주의해야 한다.  
왜냐하면 자바스크립트에서는 `this`를 호출한 객체에 따라 동적으로 바인딩해주는데, 호출하는 객체가 빌리는 객체로 바뀌기 때문이다.  
만약 프로토타입 메서드 및 해당 메서드가 호출하고 있는 객체 내부의 메서드까지 가져올 수 있으면 다행이나, 안타깝게도 그렇지 않다면 프로토타입 메서드를 통째로 빌려올 수 없다.  
따라서 이에 대한 부수효과가 발생하므로 항상 주의해야 한다.

### 기존의 상태가 바뀔 수 있다.

메서드를 빌려줄 때, 그 메서드가 현재의 객체와 이어져 있다면, 해당 메서드는 빌려준 객체의 프로퍼티에 바인딩된 값을 업데이트할 수 있다.  
이는 곧 각 객체간의 무결성을 해치기 때문에 굉장히 주의해야 하는 점이다.

## 해결 방법

1. 빌리는 객체 스스로 메서드를 제공하도록 하는 방법이 있다.
2. 빌려줄 객체를 만들어서 빌리는 객체에게 모두 제공하는 방법이 있다.