# **암호화**

평문을 해독할 수 없는 암호문으로 변환하는 것.

- 단방향(해싱)
- 양방향 암호화

### **단방향 암호화**

> 한 방향으로만 이뤄지는 알고리즘

- **해시 알고리즘을 이용하여 평문을 복호화 불가능한 형태로 암호화** (저장하는 쪽도 알면 안되는 것들 - 비밀번호)
- **`MD5`** / **`SHA`** 알고리즘이 있음
- 비밀번호 저장 시 자주 사용
- `MD5` / `SHA-0` / `SHA-1` 은 미권장.  
   **(해시 충돌이 발생할 수 있는 취약점 있기 때문)**

**고려할 점**

1. 복호화가 불가능하지만 `**Rainbow Table**`을 통해 원문을 알아낼 수 있음. (`Rainbow Table`: 평문과 해시 함수로 만든 문자열을 모두 저장시켜놓은 표)
2. 데이터를 **탈취당하더라도 원문 파악이 불가능하도록 조치**해야 함.
3. 이는 `Salt` / `Key stretching`을 이용

**`Salt`**

- 임의의 문자열을 추가하여 암호화
- 128bit 이상 만들 것 권장
- 사용자마다 다른 `Salt` 사용 권장

**`Key stretching`**

- 해시를 여러 번 반복하여 원문 난독화
- 0.2초 이상 반복되면 안전하다고 함.(일반적으로)

## **Salt와 Key stretching을 이용하는 알고리즘**

이러한 보안 관련한 것들은 직접 구현하는 것보다는 검증된 라이브러리를 사용하기를 권장한다. (그만큼 중요한 정보이기 때문)

`PBKDF2`와 `bcrypt`가 있는데, 비밀번호의 경우 `bcrypt`가 좀 더 간편하고 안전.

## **양방향 암호화**

평문을 복호화 가능한 형태로 암호화

대칭키와 비대칭키 알고리즘으로 나뉨

- 대칭키 : **`AES`**
- 비대칭키: **`RSA`**

### **대칭키 암호 알고리즘**

- 대표적으로 **`AES(Advanced Encryption Standard)`** 가 있다.
- 같은 키를 이용하여 암호화, 복호화가 가능

### **비대칭키 암호 알고리즘**

`RSA(Rivest, Shamir and Adleman)` (소인수분해를 이용)

- 대칭키만으로는 다수를 대상으로 암호문을 받기 힘들기 때문
- 모든 사람들이 대칭키를 알아야 하는데, 이는 보안상 위험
- 모든 사람들이 알아도 상관 없는 공개키 / 나만 알고 있는 개인키
- 나에게 암호를 보내고 싶은 사람들은 공개키를 이용해서 보내고, 받는 사람은 개인키를 이용하여 복호화함.

## **브라우저는 암호를 어떻게 저장하는가**

- 크롬, 사파리, 1password는 암호를 보관하고 동기화.
- 그런데 기업이, 비밀번호를 평문으로 보관하지는 않을 것.
- 어떻게 다시 복호화하여 자동완성을 한 것인가?
- 과연 안전한가?

- 특히 `1password`처럼 여러 사람들이 비밀번호를 공유하면...?

  권한 별로 공유가 가능하도록 기능을 제공한다고 해도, 같은 키는 공유하지 않을텐데...

### **1password 소개 기반 시스템 추측**

1. 사용자의 암호와 이메일을 이용하여 master allow key 생성
2. 자동생성한 평문을 암호화, 서버에 저장
3. 평문을 제거하여 아무도 알 수 없게 함.
4. 개인키는 사용자에게 전달, 공개키는 서버에 전달
5. 이후 데이터를 공개키를 이용하여 암호화
6. 각 공개키에 대응하는 비밀키로 복호화 가능

## **In JS...**

Use `crypto.js` !

단, `bcrypt` 제공 X
