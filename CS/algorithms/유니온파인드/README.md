# 유니온-파인드

> 앞으로 문제를 풀면서, 조금씩 알고리즘들을 해당 레포지토리에 이관하려 합니다.

매우 간단한 알고리즘이다.  
결국 해당 알고리즘의 핵심은 **노드가 서로 연결되었는가**라는 문제를 해결하기 위한 것이다.

## Parent

이는 원론적으로 살펴보면, 트리의 원리에 가깝다.  
왜냐! 결국 모든 것들에는 루트가 존재한다는 가정을 하게 되기 때문이다.

그렇다면 이 `Root`는 어떤 것이 가장 해를 탐색하는 데 최적일까?  
**바로 작은 수**이다. 만약 2개의 루트가 병합이 될 때, 작은 수로 병합을 한다는 로직을 갖게 되면, 결과적으로 하나의 루트로 일관성있게 병합할 수 있다.

## Find

그렇다면 결과적으로 어떤 대상의 루트를 탐색할 수 있어야 한다.  
이는 `find`라는 함수를 생성하여 재귀적으로 부모를 탐색할 수 있다.

### 경로 압축

이때, 최악의 경우 트리가 한쪽으로만 연결된 편향이진트리의 경우 O(N)까지 재귀 탐색의 시간복잡도가 수렴하게 된다.

이를 해결할 수 있는 것이 경로 압축이다. 재귀적으로 탐색하되, 루트가 아니었던 노드들을 루트로 업데이트하는 로직을 추가한다.


```js
const findParent = (x, parent) => {
  return (parent[x] === x) 
    ? x 
    : (parent[x] = findParent(parent[x], parent));
}
```

## 병합

`union`은 매우 간단하다.  
결과적으로 루트를 서로 비교하고, 더 작은 값으로 큰 루트의 `parent` 값을 갱신하면 된다.
이때의 시간 복잡도는? O(α(N))에 가깝다고 볼 수 있겠다. 왜냐! 분기 처리만 존재하지, 결과적으로 가장 큰 시간 복잡도는 `find` 함수의 시간복잡도이기 때문이다.

```js
const parentA = findParent(parent, a);
const parentB = findParent(parent, b);

if (parentA < parentB) parent[parentB] = parent[parentA];
if (parentB < parentA) parent[parentA] = parent[parentB];
```

## 최종 `parent` 업데이트 (문제에 따라 선택적)

하지만 이 역시 완전히 업데이트 된 것이 아니다. 부모만 업데이트해주었기 때문에 자식의 최종 루트가 어디인지 `parent`에는 주어지지 않았다.

결과적으로 이 노드가 모두 잘 따르도록 전체 `parent`를 탐색하며 `union-find`를 실시해주어야 한다.

그래도 `O(N)`의 시간복잡도이다. 이유는, 경로압축으로 인해 기존의 재귀 탐색 과정의 시간 복잡도를 `O(1)`에 가까이 만들었기 때문이다.

## 정리

> 참고로 나는 **유니온-파인드를 최악의 경우에서 했다**고 가정하고 쓴 글이다.
> 유니온 파인드의 시간 복잡도는 트리의 높이에 따라 결정되며, 이는 케이스가 많다 보니 딱! 이 시간 복잡도라고 말하기 어렵다.

+ 시간 복잡도: 최악의 경우 `O(N)`
  > **`(O(α(N))`라고 쓴 글이 많기는 하지만, 결과적으로 이는 경로압축으로 재구성되었을 때 실행한 얘기**이지, 본질적으로 따지면 **경로압축 과정 역시 모든 케이스들을 탐색해야 하므로 `parent`를 바꿔주는 과정**에서 O(N)이다.)
+ 공간 복잡도: `O(N)`
  > 
  > + `parent` 배열을 만듦, 
  > + 재귀탐색에서의 호출되는 스택 
  > **모두 `O(N)`을 초과하지 않음.**