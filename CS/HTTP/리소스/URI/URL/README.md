# URL

## 인터넷의 리소스 탐색

URL은 [URI](../../README.md)에서 살펴보았듯, 리소스의 위치를 가리킨다.  
이것이 `URN`과의 차이점이다. `URN`이 **그 리소스**를 가리킨다면, `URL`은 **그 리소스가 어디 있는지**를 말한다는 거다.

> 즉 **와르르멘션에 사는 짱구**라는 객체가 있다면, `URN`은 짱구를 가리키고, `URL`은 와르르멘션을 알려주어 짱구를 불러내는 거다.

이러한 `URL`은 마치 우리의 주소가 일관성 있게 나열되어 있듯이 일련의 규칙이 있다.

`https://www.jengyoung.me/about/index.html`

가령 이러한 주소가 존재한다면, 이는 다음과 같은 규칙에 의해 구성된다.

+ `scheme`: `URL`의 첫 부분이다. 어떤 프로토콜로 접근할 것인지를 알려준다. 위의 예에서는 `HTTPS`를 사용함을 알 수 있다.
+ `host`: 서버의 위치가 어디인지를 정의한다. 즉, 리소스가 어느 서버에 호스팅되어 있는지를 알려준다.
+ `route`: 리소스의 구체적인 경로를 알려준다. 서버에서 요청한 특정 리소스가 무엇인지를 알 수 있는 구체적인 경로이다.

### `URL`은 `HTTP 프로토콜`만 있는 게 아니다.

가령 프로토콜이라면, 다른 것들도 URL을 갖고 있다.
예컨대 `FTP 프로토콜`을 준수하는 URL은 다음과 같이 구성되고, 이 역시 `URL`이다.

> `ftp://ftp.lots-o-books.com/pub/complete-price-list.xls`

스트리밍을 제공하기 위한 프로토콜인 `RTSP`의 경우 다음 `URL`의 형식을 갖고 있다.

> `rtsp://www.jengyoung.com:554/interview/cto_video`

하지만 기억하자.  
모든 것은 `[[scheme]]/[[host]]/route`로 이루어져 있다. 

## 문법

![image](https://user-images.githubusercontent.com/78713176/211297975-7325ef42-98c4-4eaa-8305-dbe568b14034.png)

### Scheme

+ 사용할 프로토콜
+ 알파벳으로 시작(대소문자를 가리지 않는다.)
+ `:`문자로 다른 요소들과 구분

### 호스트, 포트 컴포넌트

+ 호스트 컴포넌트는 서버가 어디에 있는지를 전달
+ 이때, `IP` 주소가 될 수도 있고 `DNS`로 인한 주소가 될 수 있으며, 동일한 리소스의 위치가 여러 주소를 가질 수 있다.
+ 포트 컴포넌트는 서버가 열어놓은 네트워크 포트를 가리킨다.
+ 포트 컴포넌트의 경우 `HTTP`는 `80`, `HTTPS`는 `443`이 기본포트다.

### 사용자 이름, 비밀번호

`FTP`와 같은 프로토콜에서 사용한다.  
많은 서버가 자신이 갖고 있는 데이터에 접근을 하려면, 사용자 이름과 비밀번호를 요구하도록 되어 있다.

만약 사용자 이름과 비밀번호가 삽입되어 있지 않는다면 기본 사용자 이름, 비밀번호 값을 넣는다.  

+ 기본 사용자 이름: `anonymous`
+ 기본 비밀번호: 브라우저 명세마다 다름

이 두 가지 정보를 `:`로 구분하여 기록한다. 다음과 같이 말이다.

> `ftp://anonymouse:password@ftp.prep.ai.mit.edu/pub/gnu`

### 경로

리소스가 서버의 어디에 있는지를 알려준다.  
리소스는 마치 디렉토리처럼 하나의 계층 구조로 위치해 있다.  
이러한 파일 시스템 경로를 토대로, 서버의 리소스 위치를 찾을 수 있는 것이다.

### 파라미터

리소스에 접근하기 위해 더 많은 정보를 전달하기 위해 사용한다.  
예컨대 `URL`을 사용하는 애플리케이션이 리소스에 접근하려면 프로토콜 파라미터가 없을 시 요청을 잘못 처리하거나 처리하지 않을 수 있다.

`URL` 파라미터 컴포넌트는 애플리케이션이 서버에 정확한 요청을 하도록, 필요한 입력 파라미터를 받는데 사용한다.  
이는 이름/값 쌍의 리스트로 `;` 문자로 구분하여 `URL`에 기술한다.

### 쿼리 스트링

요청받을 리소스 형식의 범위를 좁혀, 원하는 데이터를 전달할 수 있도록 하는 데 사용한다.  
`URL` 질의 컴포넌트는 게이트웨이를 가리키는 `URL` 경로 컴포넌트와 함께 전달한다.  

### 프래그먼트

리소스 형식은 본래의 수준보다 더 작게 나뉠 수 있다.  
이때, 리소스의 특정 부분을 가리킬 수 있도록 리소스 내의 조각을 가리킬 수 있는 프래그먼트 컴포넌트를 제공한다.

우리가 마크다운에서 링크를 가리킬 때 `#`를 사용하여 특정 콘텐츠의 위치로 이동하는 것처럼 말이다.  

일반적으로 `HTTP` 서버는 전체만 다루기 때문에, 클라이언트는 서버에 프래그먼트를 전달하지 않는다. 즉 실제 HTTP 요청은 이루어지지 않는 것이다. 다만 브라우저는 서버로부터 리소스를 전체 내려받고, 프래그먼트를 통해 리소스의 일부를 볼 수 있다.

## 단축 URL

클라이언트의 경우 몇몇 단축 URL을 인식하고 사용할 수 있다.  
단축 URL 긴 URL을 짧은 형태로 유지하여 글자 수에 제한이 있는 메시지를 주고받을 때 사용할 수 있다.

### 절대 URL

리소스에 접근하는 데 필요한 모든 정보를 갖고 있다.

### 상대 URL

모든 정보를 갖고 있지 않다.  
다만 모든 정보를 얻기 위해서는 `base`라고 하는 다른 `URL`을 사용해야 한다.

쉽게 생각하면 우리가 `./`을 통해서 경로를 입력한다고 생각하면 편하다.  
즉, 스킴, 호스트와 포트 컴포넌트를 생략할 수 있다는 이야기다.

대개 상대 URL은 `Fragment`이거나, `URL` 일부이다.  
`URL`을 처리하는 애플리케이션의 경우 상대 URL과 절대 URL 간에 상호 변환을 할 수 있어야 한다.

이러한 처리는 다른 리소스를 결합할 때 좀 더 유연하게 변경할 수 있다는 점이 장점이다.

#### 절대 URL 변환과정

1. 기저 URL을 찾아야 한다. 이를 찾기 위한 방법은 다음과 같다.
   - `HTML 문서` 등 리소스가 명시적으로 제공한다.
   - 명시되지 않았다면 해당 리소스의 `URL`을 기저 URL로 사용한다.
   - 아예 없는 경우도 발생할 수 있다. 이는 대개 절대 URL이거나, 불완전한 URL이다.

2. 상대 참조 해석
   - 상대 URL이 어떻게 절대 URL을 구성할 수 있는지를 탐색하는 과정을 거쳐야 한다.
   - 이는 다음 그림과 같다.  
    ![image](https://user-images.githubusercontent.com/78713176/211348256-d5d8d683-b0b9-4042-992f-e10d85c64a24.png)

### URL 확장

`URL`을 입력하는 동안 자동완성되는 경우를 본 적이 있을 것이다. 이를 `URL`이 자동으로 확장된다고 표현할 수 있겠다.

이러한 확장 기능은 2가지가 있다.

+ 호스트명 확장: `yahoo` 입력시 `www.yahoo.com`이 완성
+ 히스토리 확장: `https://gith` 입력 시 `https://github.com`

### 안전하지 않은 문자

프로토콜은 기본적으로 데이터를 전송하는 데 있어 각기 다른 장치를 갖고 있다.  
따라서 어떠한 인터넷 프로토콜을 이용해서든지 간에 클라이언트는 데이터를 안전하게 응답받아야 했다.  

그렇기에 이를 참조할 수 있는 `URL`은 안전성을 보장하기 위해 여러 규칙들이 추가됐다.

이러한 규칙은 대개 문자와 관련된 규칙들이다.

#### URL 문자 집합

기존 많은 프로그램과 애플리케이션들은 `US-ASCII` 문자 집합을 채택했다.  
그러나 문제가 있다. 미국을 제외한 여러 나라의 문자를 지원할 수 없는 것이다.  

또한 `URL`이 이진 데이터를 지원할 경우에도, 문자가 죄다 깨지는 단점이 있었기 때문에, `URL`은 이스케이프 문자를 지원했다. 

#### 이스케이프 문자

`ASCII` 문자열에서 사용이 금지된 문자들이며, 이는 인코딩을 통해 이동성과 완성도를 높일 수 있도록 처리했다.

#### 인코딩 체계

안전하지 않은 문자들의 경우 다음과 같이 인코딩을 처리한다.

![image](https://user-images.githubusercontent.com/78713176/211353050-a6dfc02f-ebb0-4480-bf60-cdf06ac1cb8c.png)

### 문자 제한

마치 `const`, `let` 처럼 특정 문자들은 아예 자체적인 기능을 갖고 있는 케이스들이 존재한다.  
따라서 이러한 문자들은 게이트웨이와 프로토콜 등에서 혼동을 야기하기 때문에 사용을 주의해야 한다.

다음은 그러한 예약어와 비슷한 기능을 하는 문자들이다.
![image](https://user-images.githubusercontent.com/78713176/211353297-dda5ce6b-1513-458a-995e-f926639dc3d2.png)
![image](https://user-images.githubusercontent.com/78713176/211353350-71365779-4cfa-4a46-8ed5-2536fb20deb1.png)
