## 1960년대: RPC

`RPC(Remote Procedure Call)`을 통해 클라이언트에서 원격 컴퓨터로 요청 메시지를 보내 무언가를 할 수 있게 됐다. 즉, 클라이언트가 서버로 데이터 요청을 보내고, 서버는 응답을 돌려주는 정보 전달 방식이 나오게 된 것이다.

## 1990년대: SOAP

마이크로소프트에서 `SOAP(Simple Object Access Protocol)`이라는 개념을 도입했다. `XML`을 사용해 메시지를 인코딩하고, `HTTP`를 사용해 전송하는 것이다.

여기서 타입 시스템과 리소스 중심의 데이터 호출이라는 개념도 등장했다. 결과적으로 결과 값을 예측하기는 쉬웠으나 구현과정이 복잡하다는 문제가 발생했다.

## 2000년대: REST

로이 필딩(`Roy Fielding`)이 작성한 캘리포니아 어바인 대학 학위 논문에서 정의된 개념이다. 

`GET`, `PUT`, `POST`, `DELETE`와 같은 행동을 수행, 웹 리소스를 가지고 작업을 진행하는 리소스 중심의 아키텍처에 대한 내용이 담겨있다.

여기서 리소스 네트워크 = 가상 상태 머신이며, 위의 메서드들은 상태를 변화시키는 개념이다. 

`RESTful` 아키텍처에서 라우트는 정보를 나타내는 개념이다. 즉, 라우트를 통해 데이터에 대한 요청과 응답을 수행할 수 있는 것이다.

`END_POINT` 중심의 개발은 응답 형식을 자유롭게 생산시킬 수 있도록 하였다. 따라서 초반에는 이러한 개발 생산성으로 인해 `XML`과 같이 사용됐다.  
그렇기에 `AJAX`에서의 `X`가 `XML`인 이유는 이 때문이다. 

그리고 이러한 `XML`은 더글라스 크록포드(`Douglas Crockford`)가 `JSON`
을 만들고 표준화시키면서 점차 사용량이 줄어가며, 지금의 상황이 만들어졌다. 

이러한 `REST`이 준 생산성에 찬사를 올리며, 어떤 것이 `RESTful`한지에 매우 열띤 토론하는 사람들도 생겼는데, 이를 RESTafarian이라고 한다.

### REST의 한계

하지만 `REST`는 완벽하지 않았다. 특정 조건에서는 부하가 걸리는 조짐이 보였기 때문이다. 예컨대, 다음과 같은 한계가 있었다.

#### 1. 오버페칭

`REST`하게 짠다면, **필요하지 않은 데이터라 하더라도 특정 데이터를 가져오기 위해 어쩔 수 없이 요청해야 하는 상황**이 발생한다.
이를 오버페칭이라 한다.

#### 2. 언더페칭

기존 응답 데이터이 오히려 내가 요청하는 데이터보다 정보를 덜 담고 있을 때도 발생한다. 이럴 때에는 **어쩔 수 없이 원하는 데이터를 더 얻기 위해 추가적으로 데이터를 요청해야 하는 상황이 발생**한다. 이를 언더페칭이라 한다.

#### 3. 엔드 포인트 관리

`REST`의 가장 큰 결점 중 하나는 유연성이 부족하다.  

부연 설명하자면, 나는 간단히 데이터를 조금 변형해서 사용하고 싶은데, 그렇기 위해서는 추가적으로 엔드포인트를 만들어야 하는 상황이 발생한다는 것이다. 

이를 통해 엔드포인트 개수가 정말 기하급수적으로 늘어나게 될 가능성이 많으며, 따라서 프론트엔드와 백엔드가 서로 협력하며 짜야 하기에 의사 소통 시간이 길어진다. 

이러한 `REST`에 반해 `GraphQL`은 이러한 소통 시간을 줄이고, 엔드포인트를 최대한 줄여 대개 하나로 끝낸다. 

이는 단일 엔드포인트가 게이트웨이로써 
+ 데이터 소스를 조율하는 역할 
+ 데이터 체계를 관리하기 용이하게 하는 역할

을 수행하게 한다. 

### 유의 사항
핵심은 많은 조직이 `GraphQL`과 `REST`를 같이 사용한다는 것이다.  
`GraphQL`의 엔드포인트를 만들어 `REST` 엔드포인트의 데이터를 가져오는 작업 방식은 유효한 `GraphQL` 사용법이며, 이는 `GraphQL`의 유연성을 보여준다. 

> 따라서 `GraphQL`은 점진적으로 프로젝트에 도입 가능한 훌륭한 전략이다. 


